<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_ui_script">
    <sys_ui_script action="INSERT_OR_UPDATE">
        <active>true</active>
        <description/>
        <global>false</global>
        <ignore_in_now_experience>false</ignore_in_now_experience>
        <name>x_680259_scm.scm_helpers.js</name>
        <script><![CDATA[// Initialize global object if it doesn't exist
scm_scratchpad = typeof scm_scratchpad !== 'undefined' ? scm_scratchpad : {};

// Fill scm_scratchpad with helper functions if not already defined
scm_scratchpad.document = document;
scm_scratchpad.window = window;
scm_scratchpad.angular = typeof angular !== 'undefined' ? angular : null;
scm_scratchpad.glideAjax = scmGlideAjaxAsync; // Helper function for Promise-based GlideAjax calls
scm_scratchpad.eventManager = new SCM_EventManager(); // This object helps debugging all GlideAjax calls

/**
 * Helper function to perform GlideAjax calls using Promises
 * @param {string} scriptInclude - Name of the Script Include
 * @param {string} methodName - Name of the method to call
 * @param {Object} params - Parameters to pass to the method
 * @returns {Promise} - Resolves with the server response
 */
function scmGlideAjaxAsync(scriptInclude, methodName, params) {
	const eventId = scm_scratchpad.eventManager.addEvent('GlideAjax Call Started', {
		scriptInclude,
		methodName,
		params
	});

	const returnPromise = new PromiseRejectionEvent(resolve => {
		const ga = new GlideAjax(scriptInclude);
		ga.addParam('sysparm_name', methodName);
		for (const key in params) {
			if (params.hasOwnProperty(key)) {
				ga.addParam(key, params[key]);
			}
		}

		ga.getXML(response => {
			const answer = response.responseXML.documentElement.getAttribute('answer');
			scm_scratchpad.eventManager.resolveEvent(eventId);
			answer.eventId = eventId;
			resolve(answer);
		});

		ga.setErrorCallback(response => {
			scm_scratchpad.eventManager.failEvent(eventId, 'Server responded with an error');
			console.error('GlideAjax Error Response:', scriptInclude, response);
		});
	});

	// Assign eventId to be able to get debug information from
	// EventManager (custom made SCM object) using this event Id
	returnPromise.eventId = eventId;

	return returnPromise;
}

/**
 * Event Manager to track and debug events such as GlideAjax calls
 */
function SCM_EventManager() {
	this.currentEventId = 0;
	this.currentEvents = [];

	/**
	 * Adds a new event to the event manager
	 * @param {*} name - The name of the event
	 * @returns {number} - The ID of the created event
	 */
	this.addEvent = name => {
		const id = this.currentEventId++;
		this.currentEvents.push({
			id,
			name,
			status: 1,
			message: '',
			timeStarted: new Date().getTime(),
			timeElapsed: 0
		});
		return id;
	};

	/**
	 * Resolves an event by its ID
	 * @param {*} id - The ID of the event to resolve
	 */
	this.resolveEvent = id => {
		const that = this;
		this.currentEvents.forEach((event, index) => {
			if (event.id === id) {
				that.currentEvents[index].status = 0;
				that.currentEvents[index].timeElapsed = new Date().getTime() - that.currentEvents[index].timeStarted;
			}
		});
	};

	/**
	 * Fails an event by its ID
	 * @param {*} id - The ID of the event to fail
	 * @param {*} message - The failure message
	 */
	this.failEvent = (id, message) => {
		const that = this;
		this.currentEvents.forEach((event, index) => {
			if (event.id === id) {
				that.currentEvents[index].status = 500;
				that.currentEvents[index].message = message;
				that.currentEvents[index].timeElapsed = new Date().getTime() - that.currentEvents[index].timeStarted;
			}
		});
	};

	/**
	 * Retrieves all current events
	 * @returns {Array} - Array of current events
	 */
	this.getEvents = () => {
		return this.currentEvents;
	};

	/**
	 * Logs current events to the console for debugging
	 */
	this.debug = function () {
		console.table(this.currentEvents);
	};
}

/**
 * Custom handler for input elements to sync value with sdx custom element
 * @param {HTMLElement} element
 */
function sdxInputHandler(element) {
	var value = element.value || '';
	var sdxElement = element.el;
	sdxElement.setAttribute('value', value);
}

/**
 * Custom handler for input elements of type select to sync selected value with sdx custom element
 * @param {HTMLElement} element
 */
function sdxSelectHandler(element) {
	var value = element.value[0] || '';
	var sdxElement = element.el;
	sdxElement.setAttribute('value', value);
}
]]></script>
        <script_name>scm_helpers.js</script_name>
        <sys_class_name>sys_ui_script</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-07-11 18:04:57</sys_created_on>
        <sys_id>7862ffeb836a2650efda54b6feaad38e</sys_id>
        <sys_mod_count>3</sys_mod_count>
        <sys_name>x_680259_scm.scm_helpers.js</sys_name>
        <sys_package display_value="SCM" source="x_680259_scm">9b70ffe7836a2650efda54b6feaad334</sys_package>
        <sys_policy/>
        <sys_scope display_value="SCM">9b70ffe7836a2650efda54b6feaad334</sys_scope>
        <sys_update_name>sys_ui_script_7862ffeb836a2650efda54b6feaad38e</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-28 10:05:59</sys_updated_on>
        <ui_type>0</ui_type>
        <use_scoped_format>false</use_scoped_format>
    </sys_ui_script>
</record_update>
